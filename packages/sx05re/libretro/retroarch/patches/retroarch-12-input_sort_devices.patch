diff --git a/input/drivers_joypad/udev_joypad.c b/input/drivers_joypad/udev_joypad.c
index 4b985f1953..d66e2b50d3 100644
--- a/input/drivers_joypad/udev_joypad.c
+++ b/input/drivers_joypad/udev_joypad.c
@@ -590,6 +590,14 @@ static void udev_joypad_poll(void)
    }
 }
 
+/* Used for sorting devnodes to appear in the correct order */
+static int sort_devnodes(const void *a, const void *b)
+{
+   const struct joypad_udev_entry *aa = (const struct joypad_udev_entry*)a;
+   const struct joypad_udev_entry *bb = (const struct joypad_udev_entry*)b;
+   return strcmp(aa->devnode, bb->devnode);
+}
+
 static void *udev_joypad_init(void *data)
 {
    unsigned i;
@@ -625,11 +633,31 @@ static void *udev_joypad_init(void *data)
    if (!devs)
       RARCH_DBG("[udev]: Couldn't open any joypads. Are permissions set correctly for /dev/input/event* and /run/udev/?\n");
 
-   udev_list_entry_foreach(item, devs)
+   for (item = devs; item; item = udev_list_entry_get_next(item))
    {
       const char         *name = udev_list_entry_get_name(item);
       struct udev_device  *dev = udev_device_new_from_syspath(udev_joypad_fd, name);
       const char      *devnode = udev_device_get_devnode(dev);
+      if (devnode != NULL) {
+         sorted[sorted_count].devnode = devnode;
+         sorted[sorted_count].item = item;
+         sorted_count++;
+      } else {
+         udev_device_unref(dev);
+      }
+   }
+
+   /* Sort the udev entries by devnode name so that they are
+    * created in the proper order */
+   qsort(sorted, sorted_count,
+         sizeof(struct joypad_udev_entry), sort_devnodes);
+
+   for (i = 0; i < sorted_count; i++)
+   {
+      const char         *name = udev_list_entry_get_name(sorted[i].item);
+      struct udev_device  *dev = udev_device_new_from_syspath(udev_joypad_fd, name);
+      const char      *devnode = udev_device_get_devnode(dev);
+
 #if defined(DEBUG)
       struct udev_list_entry *list_entry = NULL;
       RARCH_DBG("udev_joypad_init entry name=%s devnode=%s\n", name, devnode);

